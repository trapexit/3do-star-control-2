/*
 * LZHUF.C English version 1.0
 * Based on Japanese version 29-NOV-1988
 * LZSS coded by Haruhiko OKUMURA
 * Adaptive Huffman Coding coded by Haruyasu YOSHIZAKI
 * Edited and translated to English by Kenji RIKITAKE
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "lzh.h"
#include "timlib.h"

LPLZHCODE_DESC	_lpCurCodeDesc;
STREAM_TYPE	_StreamType;
LPBYTE		_Stream;
UWORD		_workbuf;
BYTE		_workbuflen;

PROC(STATIC
SWORD near GetBit, (),	/* get one bit */
    ARG_VOID
)
{
    SWORD	i;

    while (_workbuflen <= 8)
    {
	if ((i = InChar ()) < 0)
	    i = 0;
	_workbuf |= i << (8 - _workbuflen);
	_workbuflen += 8;
    }
    i = (_workbuf & 0xFFFF) >> (16 - 1);
    _workbuf = (_workbuf << 1) & 0xFFFF;
    _workbuflen--;

    return (i);
}

PROC(STATIC
UWORD near GetBits, (num_bits),
    ARG_END	(BYTE	num_bits)
)
{
    SWORD	i;

    while (_workbuflen <= 8)
    {
	if ((i = InChar ()) < 0)
	    i = 0;
	_workbuf |= i << (8 - _workbuflen);
	_workbuflen += 8;
    }
    i = (_workbuf & 0xFFFF) >> (16 - num_bits);
    _workbuf = (_workbuf << num_bits) & 0xFFFF;
    _workbuflen -= num_bits;

    return (i);
}

/* initialize freq tree */

PROC(
void near StartHuff, (),
    ARG_VOID
)
{
    COUNT	i, j;

    for (i = 0; i < N_CHAR; i++)
    {
	_lpCurCodeDesc->freq[i] = 1;
	_lpCurCodeDesc->son[i] = i + T;
	_lpCurCodeDesc->prnt[i + T] = i;
    }
    i = 0; j = N_CHAR;
    while (j <= R)
    {
	_lpCurCodeDesc->freq[j] = _lpCurCodeDesc->freq[i] + _lpCurCodeDesc->freq[i + 1];
	_lpCurCodeDesc->son[j] = i;
	_lpCurCodeDesc->prnt[i] = _lpCurCodeDesc->prnt[i + 1] = j;
	i += 2; j++;
    }
    _lpCurCodeDesc->freq[T] = 0xffff;
    _lpCurCodeDesc->prnt[R] = 0;
}

PROC(
DECODE_REF copen, (InStream, SType, SMode),
    ARG		(LPVOID		InStream)
    ARG		(STREAM_TYPE	SType)
    ARG_END	(STREAM_MODE	SMode)
)
{
    MEM_HANDLE	h;
    DWORD	StreamLength;

    _StreamType = SType;
    _Stream = InStream;
    if (SMode == STREAM_WRITE)		/* writing */
    {
	OutChar (0);	/* skip future StreamLength */
	OutChar (0);
	OutChar (0);
	OutChar (0);

	StreamLength = 0;
    }
    else		/* reading */
    {
	BYTE	lobyte, hibyte;
	UWORD	loword, hiword;

	lobyte = (BYTE)InChar ();
	hibyte = (BYTE)InChar ();
	loword = MAKE_WORD (lobyte, hibyte);
	lobyte = (BYTE)InChar ();
	hibyte = (BYTE)InChar ();
	hiword = MAKE_WORD (lobyte, hibyte);

	StreamLength = MAKE_DWORD (loword, hiword);
    }

    h = 0;
    if (StreamLength == 0xFFFFFFFF
	    || (h = AllocCodeDesc ()) == 0
	    || (_lpCurCodeDesc = LockCodeDesc (h)) == 0)
    {
	_lpCurCodeDesc = 0;
	FreeCodeDesc (h);
    }
    else
    {
	_lpCurCodeDesc->fh = h;
	_lpCurCodeDesc->Stream = _Stream;
	_lpCurCodeDesc->StreamType = _StreamType;
	_lpCurCodeDesc->StreamMode = SMode;
	_lpCurCodeDesc->StreamLength = StreamLength;
	_lpCurCodeDesc->buf_index = N - F;
	MEMSET ((LPBYTE)&_lpCurCodeDesc->text_buf[0], ' ', N - F);

	StartHuff ();
    }

    return ((DECODE_REF)_lpCurCodeDesc);
}

PROC(
DWORD cclose, (lpCodeDesc),
    ARG_END	(LPLZHCODE_DESC	lpCodeDesc)
)
{
    if (_lpCurCodeDesc = lpCodeDesc)
    {
	DWORD	StreamIndex;

	if (_lpCurCodeDesc->CleanupFunc)
	    (*_lpCurCodeDesc->CleanupFunc) ();

	StreamIndex = lpCodeDesc->StreamIndex;
	UnlockCodeDesc (lpCodeDesc->fh);
	FreeCodeDesc (lpCodeDesc->fh);

	return (StreamIndex);
    }

    return (0);
}

PROC(
void cfilelength, (lpCodeDesc, pfilelen),
    ARG		(LPLZHCODE_DESC	lpCodeDesc)
    ARG_END	(DWORD		*pfilelen)
)
{
    if (lpCodeDesc == 0)
	*pfilelen = 0;
    else
	*pfilelen = lpCodeDesc->StreamLength;
}

	/* decoder table */
static CONST BYTE	far d_code[256] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
    0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
    0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
    0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
    0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
    0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
    0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0C, 0x0C, 0x0C, 0x0C, 0x0D, 0x0D, 0x0D, 0x0D,
    0x0E, 0x0E, 0x0E, 0x0E, 0x0F, 0x0F, 0x0F, 0x0F,
    0x10, 0x10, 0x10, 0x10, 0x11, 0x11, 0x11, 0x11,
    0x12, 0x12, 0x12, 0x12, 0x13, 0x13, 0x13, 0x13,
    0x14, 0x14, 0x14, 0x14, 0x15, 0x15, 0x15, 0x15,
    0x16, 0x16, 0x16, 0x16, 0x17, 0x17, 0x17, 0x17,
    0x18, 0x18, 0x19, 0x19, 0x1A, 0x1A, 0x1B, 0x1B,
    0x1C, 0x1C, 0x1D, 0x1D, 0x1E, 0x1E, 0x1F, 0x1F,
    0x20, 0x20, 0x21, 0x21, 0x22, 0x22, 0x23, 0x23,
    0x24, 0x24, 0x25, 0x25, 0x26, 0x26, 0x27, 0x27,
    0x28, 0x28, 0x29, 0x29, 0x2A, 0x2A, 0x2B, 0x2B,
    0x2C, 0x2C, 0x2D, 0x2D, 0x2E, 0x2E, 0x2F, 0x2F,
    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
    0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
};
static CONST BYTE	far d_len[256] =
{
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
    0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
    0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
    0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
    0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
    0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
    0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
    0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
    0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
    0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
    0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
    0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
    0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
    0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
    0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
    0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
    0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
    0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
    0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
    0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
    0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
    0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
};

    /* decode upper 6 bits from given table */
#define DecodePosition(p)	\
{ \
    while (_workbuflen <= 8) \
    { \
	*(p) = InChar (); \
	_workbuf |= *(p) << (8 - _workbuflen); \
	_workbuflen += 8; \
    } \
    *(p) = HIBYTE (_workbuf); \
    _workbuf = (_workbuf << 8) & 0xFFFF; \
    _workbuflen -= 8; \
    \
    /* input lower 6 bits directly */ \
    j = d_len[*(p)]; \
    *(p) = ((UWORD)d_code[*(p)] << 6) \
	    | (((*(p) << j) | GetBits (j)) & 0x3f); \
}

    /* start searching tree from the root to leaves.
     * choose node #(son[]) if input bit == 0
     * else choose #(son[]+1) (input bit == 1)
     */
#define DecodeChar(c)	\
{ \
    for (*(c) = lpCodeDesc->son[R]; \
	    *(c) < T; \
	    *(c) = lpCodeDesc->son[*(c) + GetBit ()]) \
	; \
    _update (*(c)); \
    *(c) -= T; \
}

PROC(
COUNT cread, (buf, size, count, lpCodeDesc),
    ARG		(LPVOID				buf)
    ARG		(COUNT				size)
    ARG		(COUNT				count)
    ARG_END	(register LPLZHCODE_DESC	lpCodeDesc)
)
{
    COUNT	r, i, j;
    LPBYTE	lpStr;

    if ((_lpCurCodeDesc = lpCodeDesc) == 0)
	return (0);

    size *= count;
    if (lpCodeDesc->StreamIndex + size > lpCodeDesc->StreamLength)
    {
	size /= count;
	count = (COUNT)((lpCodeDesc->StreamLength
		- lpCodeDesc->StreamIndex) / size);

	size *= count;
    }

    if (size == 0)
	return (0);

    lpStr = (LPBYTE)buf;
    _StreamType = lpCodeDesc->StreamType;

    _Stream = lpCodeDesc->Stream;
    _workbuf = lpCodeDesc->workbuf;
    _workbuflen = lpCodeDesc->workbuflen;

    lpCodeDesc->StreamIndex += size;
    r = lpCodeDesc->buf_index;
    if (j = lpCodeDesc->bytes_left)
    {
	lpCodeDesc->bytes_left = 0;
	i = lpCodeDesc->restart_index;

	goto ReenterRun;
    }

    do
    {
	COUNT	c;

	DecodeChar (&c);

	if (c < 256)
	{
	    size--;

	    *lpStr++ = lpCodeDesc->text_buf[r++ & (N - 1)] = (BYTE)c;
	}
	else
	{
	    COUNT	copy_size;

	    DecodePosition (&i);
	    i = r - i - 1;
	    j = c - 255 + THRESHOLD;
ReenterRun:
	    if (j > size)
	    {
		lpCodeDesc->bytes_left = j - size;
		lpCodeDesc->restart_index = i + size;
		j = size;
	    }

	    size -= j;
	    do
	    {
		COUNT	loc_size;

		i &= (N - 1);
		r &= (N - 1);
		if ((i < r && i + j > r) || (i > r && i + j > r + N))
		    copy_size = (r - i) & (N - 1);
		else if ((copy_size = j) > N)
		    copy_size = N;

		loc_size = copy_size;
		if (i + loc_size > N)
		{
		    COUNT	k;

		    k = N - i;
		    MEMCPY (lpStr, &lpCodeDesc->text_buf[i], k);
		    lpStr += k;
		    loc_size -= k;
		    i = 0;
		}

		MEMCPY (lpStr, &lpCodeDesc->text_buf[i], loc_size);
		lpStr += loc_size;
		i += loc_size;

		lpStr -= copy_size;

		loc_size = copy_size;
		if (r + loc_size > N)
		{
		    COUNT	k;

		    k = N - r;
		    MEMCPY (&lpCodeDesc->text_buf[r], lpStr, k);
		    lpStr += k;
		    loc_size -= k;
		    r = 0;
		}

		MEMCPY (&lpCodeDesc->text_buf[r], lpStr, loc_size);
		lpStr += loc_size;
		r += loc_size;
	    } while (j -= copy_size);
	}
    } while (size);

    if (_StreamType == MEMORY_STREAM)
    {
	FAR_PTR_ADD (&_Stream, 0);
    }

    lpCodeDesc->buf_index = r;
    lpCodeDesc->Stream = _Stream;
    lpCodeDesc->workbuf = _workbuf;
    lpCodeDesc->workbuflen = _workbuflen;

    return (count);
}

